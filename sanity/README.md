# Sanity Schema and Studio for Austen Riggs Center

## Codegen

We use the `sanity-codegen` package to generate typescript types based on our
schema for use with client side code. Currently the codegen is run manually via
`yarn codegen`, and the resulting types are added to source control.

### Future use of the `sanity-codegen` package

Right now we are only using `sanity-codegen` to generate types. In the future we
may want to explore using the included client which is capable of returning
strongly typed results for a query.

In the meantime we are sticking with our more manual but loosely-coupled
approach as implemented in `web/data/` for a couple reasons:

- This client (like the official sanity client) does not currently expand
  references. We have code to handle this written, that would need to be ported.
- These tools are currently pre-release and subject to some pretty big changes
  coming soon.

## Notes:

### 'Section' and 'Block' naming convention kerfuffle

we are in the midst of renaming 'blocks' to 'sections' when referring to the
arrangeable page-builder components. This is ugly and annoying and Adam is very
sorry.

We are doing this because 'blocks' is already used by sanity to refer to portable
text content entries. Within this document and much of the data mapping code, the
two should be considered equivalent.

### Static typing of sanity page-building sections during mapping

Actually, there is none. Previously we were using a union type called
`AnyBlockData`, an array of which is returned from any page with page-building
sections. In each section, we had a special read-only field called `blockType`
which would be present and sufficiently unique to discriminate the union and
select a more specific type as needed.

This was all kind of messy and complicated, and only really used in  
`web/components/BlockMapper`. Furthermore, that code isn't made any less verbose
via strong typing.

The current approach is to simply trust that the mapping code knows what it's
doing. All other downstream code, including the individual mapping functions
co-located with their respective page-building components, is statically typed.

The old logic that switched on `blockType` works the same, but switches on the
sanity-supplied `_type` property which is set based on the `name` property as
defined in each section's schema definition.

This will should more sense in context of the following step-by-step guide.

## Step-by-step guide to creating new page-builder sections, from schema to component

### 1. Create a schema file for your section in `sanity/schemas/sections`.

This will usually be an object (vs document) schema, that will define all the
fields needed to represent the section in the CMS. The `name` property will be
used by web-side code to identify sections coming in from the client, which
delivers it as `_type`

If you have created a new schema file, be sure to import and include it in
`sanity/schemas/schema.js` along with other section entries.

### 2. Run the Code Gen

In the sanity project run `yarn codegen` to re-create types derived from the
schema files. Any time we add or change schema files we should run this.
Resulting type definitions are saved in `sanity/schemas/types.ts` which _should
not be edited by hand._

### 3. Create a client-side type for the new section.

Client-side types for our sections live in `web/data/blocks`.

Here we could manually write out a type for each section that would match our
expectations for that section as it comes in from the sanity client. This type
would need to include all the fields defined in the schema as well as a \_key
field. The type would also need to account for the fact that we expand most
(currently all) references returned by the client into their actual
object/document.

Instead, we mainly rely on the types generated by the `sanity-codegen` package,
using a few utility types to do the work of including keys and expanding references.

For example in `web/data/blocks/TextAndImageBlockData.ts` the entire section is
defined with the following code:

```ts
import type {TextAndImageBlock, SanityKeyed} from '@schema/types';
import type {ResolvedSanityReferences} from '@data/types';

export type TextAndImageBlockData = SanityKeyed<
  ResolvedSanityReferences<TextAndImageBlock>
>;

export default TextAndImageBlockData;
```

These simplifications will likely be taken further in the future collapsing all
of these files into one, as the type definitions are only a line or so of code.

### 4. write mapping code

The current convention is to add the mapping code as a default export of a file
named `_map.tsx` that lives next to the component to be mapped. This convention
may be used in future automation.

The mapping function should take as input the section type we just defined, and
return a react component rendering that section. An example can be found at
`web/components/TextAndImageBlock/_map.tsx`

### 5. invoke mapping code in Section Mapper

The section mapper (called BlockMapper currently) lives at
`web/components/BlockMapper/BlockMapper.tsx` and comprises a long list
of inelegant but effective if statements. Here we key on the `_type` property
of the passed in sections (which themselves were returned from the sanity client)
to select the appropriate mapping function.

In the future this will be more elegantly
automated, but it works well for the moment.

Add the newly created mapping section inside it's appropriate if statement

### 6. Done!

With these steps complete, we should be able to add our new section type to any
page-builder document, and then observe that section client side.
