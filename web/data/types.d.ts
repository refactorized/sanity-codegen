import type {
  SanityKeyed,
  SanityDocument,
  SanityKeyedReference,
  SanityReference,
  SanitySlug,
  SanityImageAsset,
  BasicText,
  Category,
  Link as _Link,
  PtImage as _PtImage,
  PtFile as _PtFile,
  PtEmbed as _PtEmbed,
  Page,
} from '@schema/types';

export type BasicText = BasicText;

// these are always present on data that comes in from sanity
export interface PageSection {
  _type: string;
  _key: string;
}

export type PageDocument = ResolvedSanityReferences<Page>;

export interface FooterLink {
  title: string;
  slug: {current: string};
  _key: string;
}
export interface FooterConfig {
  col1: FooterLink[];
  col2: FooterLink[];
  col3: FooterLink[];
  col4: FooterLink[];
  col5: FooterLink[];
}
export type SiteConfig = ResolvedSanityReferences<{
  announcementBarShow: boolean;
  announcementBarMessage: string;
  announcementBarCtaText: string;
  announcementBarCtaLink: Link;
  AddressLine1: string;
  AddressLine2: string;
  email: string;
  phone: string;
  fax: string;
  footerConfig: FooterConfig;
  featuredLinkLabel: string;
  featuredLinkUrl: Link;
  logInLinkLabel: string;
  logInLinkUrl: Link;
  registerLink: string;
  registerUrl: Link;
  phoneNumber: string;
  navConfig: NavConfig;
  privatePolicy: string;
}>;

export type ResolvedPageInfo = ResolvedSanityReferences<{
  _type: 'resolvedPageInfo'; // using pageInfo here creates a cyclic mapping
  title?: string;
  slug?: {_type: 'slug'; current: string};
  category?: Category;
  description?: string;
  openGraphImage?: {
    _type: 'image';
    asset: SanityReference<SanityImageAsset>;
    crop?: SanityImageCrop;
    hotspot?: SanityImageHotspot;
  };
}>;

export type ResolvedPageLink = {
  _type: 'slug';
  current: string;
};

export type ResolvedAsset = {
  _createdAt: string; //       "2021-10-21T02:35:30Z"
  _id: string; //              "file-243d8582c752f3cf4751449b8777c9099145fcf5-pdf"
  _rev: string; //             "19n1LyYALxxMWkHWbYw1ju"
  _type: string; //            "sanity.fileAsset"
  _updatedAt: string; //       "2021-10-21T02:35:30Z"
  assetId: string; //          "243d8582c752f3cf4751449b8777c9099145fcf5"
  extension: string; //        "pdf"
  mimeType: string; //         "application/pdf"
  originalFilename: string; // "Hip-Hop-Beats.pdf"
  path: string; //             "files/97aou580/production/243d8582c752f3cf4751449b8777c9099145fcf5.pdf"
  sha1hash: string; //         "243d8582c752f3cf4751449b8777c9099145fcf5"
  size: number; //             12345
  uploadId: string; //         "h7miVTgbh8iuHG5TONa6mqnaL5ojxPhz"
  url: string; //              "https://cdn.sanity.io/files/97aou580/production/243d8582c752f3cf4751449b8777c9099145fcf5.pdf"
};

// Special case, sanity-codegen gives us uncharacteristically useless types for
// the sanity schema type `file`, which breaks our typical resolution, so we
// will replace the tyoe outright. extending T here allows us to include extra
// fields defined in the file object as defined by the schema.
interface ResolvedSanityFile<T> extends T {
  _type: 'file';
  asset: ResolvedAsset;
}

// this will match the standard sanity file schema type
interface MatchSanityFile<T> extends T {
  _type: 'file';
}

// see: https://github.com/ricokahler/sanity-codegen/issues/175#issuecomment-900805132
// recursively resolve sanity references for a given type
export type ResolvedSanityReferences<T> =
  // match standard Files and explicitly resolve inner asset
  T extends MatchSanityFile<infer U>
    ? ResolvedSanityFile<U>
    : // match `SanityKeyedReference` and unwrap via `infer U`
    T extends SanityKeyedReference<infer U>
    ? ResolvedSanityReferences<U>
    : // match `SanityReference` and unwrap via `infer U`
    T extends SanityReference<infer U>
    ? ResolvedSanityReferences<U>
    : // resolve pageInfo references (see note below)
    T extends {_type: 'pageInfo'}
    ? ResolvedPageInfo
    : // resolve pageLink references (see note below)
    T extends {_type: 'pageLink'}
    ? ResolvedPageLink
    : // match arrays, unwrap with `T[number]`,
    // recursively run through `ResolvedSanityReferences`
    // then re-wrap in an another array
    T extends any[]
    ? Array<ResolvedSanityReferences<T[number]>>
    : // finally utilize mapped types to
      // recursively run children through `ResolvedSanityReferences`
      {[P in keyof T]: ResolvedSanityReferences<T[P]>};

// Note: above, we are explicitly spelling out types like {_type: 'pageLink'}
// because the types generated by sanity-codegen do not use the correct value
// for _type, which is what our resolvers key on.

export type Link = ResolvedSanityReferences<_Link>;
export type PtImage = ResolvedSanityReferences<_PtImage>;
export type PtFile = ResolvedSanityReferences<_PtFile>;
export type PtEmbed = _PtEmbed; // no refs to resolve
